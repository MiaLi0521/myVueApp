<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>计算属性和侦听器</title>
</head>
<body>
    <!-- 模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如：
        <div id="example">
            {{ message.split('').reverse().join('') }}
        </div>
        对于任何复杂逻辑，你都应当使用计算属性。
    -->
    <div id=example>
        <p>Original message: {{ message }}</p>
        <p>Computed reversed message: : {{ reversedMessage }}</p>
    </div>

    <!-- 计算属性缓存 VS 方法 -->
    <!-- 我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。
        然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。
        这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。 
    -->
    <div id=example2>
        <p>Original message: {{ message }}</p>
        <p>Reversed message by method: : {{ reversedMessage() }}</p>
        <p>Time: {{ now }}</p>
    </div>

    <!-- 计算属性 VS 侦听器 -->
    <div id=demo>{{ fullName }}</div>
    <div id=demo2>{{ fullName }}</div>

    <!-- 计算属性的setter -->
    <div id=demo3>{{ fullName }}</div>

    <!-- 侦听器 -->
    <!-- 虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。
        这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。
        当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。
     -->
    <div id=watch-example>
        <p>
            Ask a yes/no question?
            <input v-model="question">
        </p>
        <p>{{ answer }}</p>
    </div>
</body>
<script src="../vue.js"></script>
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script src="../lodash.min.js"></script>
<script>
    /*
    你可以像绑定普通 property 一样在模板中绑定计算属性。
    Vue 知道 vm.reversedMessage 依赖于 vm.message，因此当 vm.message 发生改变时，所有依赖 vm.reversedMessage 的绑定也会更新。
    */
    var vm = new Vue({
        el: '#example',
        data: {
            message: 'Hello',
        },
        computed: {
            reversedMessage: function() {
                return this.message.split('').reverse().join('')
            }
        }
    })

    /*
    我们为什么需要缓存？
    假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。
    然后我们可能有其他的计算属性依赖于 A。如果没有缓存，我们将不可避免的多次执行 A 的 getter！
    如果你不希望有缓存，请用方法来替代。
    */
    var vm2 = new Vue({
        el: '#example2',
        data: {
            message: 'Vue',
        },
        computed: {
            // 下面的计算属性将不再更新，因为 Date.now() 不是响应式依赖
            now: function(){
                return Date.now()
            }
        },
        methods: {
            reversedMessage: function(){
                return this.message.split('').reverse().join('')
            }
        }
    })

    var demo = new Vue({
        el: '#demo',
        data: {
            firstName: 'Foo',
            lastName: 'Bar',
            fullName: 'Foo Bar'
        },
        watch: {
            // 反例：滥用时间监听
            firstName: function(val){
                this.fullName = val + ' ' + this.lastName
            },
            lastName: function(val){
                this.fullName = this.firstName + ' ' + this.lastName
            }
        }
    })

    // 使用计算属性优化上例
    var demo2 = new Vue({
        el: '#demo2',
        data: {
            firstName: 'Foo',
            lastName: 'Bar',
        },
        computed: {
            fullName: function(){
                return this.firstName + ' ' + this.lastName
            }
        }
    })

    // 计算属性默认只有 getter，不过在需要时你也可以提供一个 setter
    var demo3 = new Vue({
        el: '#demo3',
        data: {
            firstName: 'Foo',
            lastName: 'Bar',
        },
        computed: {
            fullName: {
                get: function () {
                    return this.firstName + ' ' + this.lastName
                },
                set: function(val){
                    var names = val.split(' ')
                    this.firstName = names[0]
                    this.lastName = names[names.length - 1]
                }
            }
        }
    })

    var watchExampleVM = new Vue({
        el: '#watch-example',
        data: {
            question: '',
            answer: 'I cannot give you an answer until you ask a question!',
        },
        /*
        使用 watch 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。
        这些都是计算属性无法做到的。
        */
        watch: {
            // 如果question发生变化，这个函数就运行
            question: function(newQuestion, oldQuestion){
                this.answer = 'Waiting for you to stop typing...'
                this.debouncedGetAnswer()
            }
        },
        created: function(){
            this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)
        },
        methods: {
            getAnswer: function(){
                // 找不到为-1
                if (this.question.indexOf('?') === -1){
                    this.answer = 'Questions usually contain a question mark. ;-)'
                    return
                }
                this.answer = 'Thinking...'
                var vm = this
                axios.get("https://yesno.wtf/api").then(function (response){
                    vm.answer = _.capitalize(response.data.answer)
                }).catch(function(error){
                    vm.answer = 'Error! Could not reach the API. ' + error
                }
                )
            }
        }
    })
</script>
</html>